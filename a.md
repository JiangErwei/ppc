# 未对齐内存示例

假设我们有两个数组 a 和 b，每个元素都是 4 字节（float）。

| 内存地址 | 数组 a          | 数组 b          |
|----------|------------------|-----------------|
| 0x1000   | a[0] (4 bytes)   | b[0] (4 bytes)  |
| 0x1004   | a[1] (4 bytes)   | b[1] (4 bytes)  |
| 0x1008   | a[2] (4 bytes)   | b[2] (4 bytes)  |
| 0x100C   | a[3] (4 bytes)   | b[3] (4 bytes)  |
| 0x1010   | a[4] (4 bytes)   | b[4] (4 bytes)  |
| 0x1014   | a[5] (4 bytes)   | b[5] (4 bytes)  |
| 0x1018   | a[6] (4 bytes)   | b[6] (4 bytes)  |
| 0x101C   | a[7] (4 bytes)   | b[7] (4 bytes)  |

默认情况下，内存可能未按 16 字节对齐。

| 内存地址 | 数组 a          |
|----------|------------------|
| 0x1000   | a[0] (4 bytes)   |
| 0x1004   | a[1] (4 bytes)   |
| 0x1008   | a[2] (4 bytes)   |
| 0x100C   | a[3] (4 bytes)   |
| 0x1010   | a[4] (4 bytes)   |
| 0x1014   | a[5] (4 bytes)   |
| 0x1018   | a[6] (4 bytes)   |
| 0x101C   | a[7] (4 bytes)   |

# 对齐内存示例

通过 `posix_memalign` 或 `aligned_alloc` 分配对齐的内存，可以确保内存地址按 16 字节对齐。

| 内存地址 | 数组 a                                         |
|----------|------------------------------------------------|
| 0x1000   | a[0] (4 bytes) | a[1] (4 bytes) | a[2] (4 bytes) | a[3] (4 bytes) |
| 0x1010   | a[4] (4 bytes) | a[5] (4 bytes) | a[6
